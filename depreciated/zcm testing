// // main.c

// // unit testing for publish.c main function


#include <unistd.h>
#include <zcm/zcm.h>
#include "sensor_info_t.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <termios.h>
#include <fcntl.h>
#include <string.h>



// Function to read data from the file descriptor
int readData(int fd, char* buf, int bufSize) {
    return read(fd, buf, bufSize);
}

// Function to parse the buffer and update the sensor_info_t structure
void parseBuffer(sensor_info_t* msg, char* buf) {
    char* token = strtok(buf, " ");
    int count = 0;
    while (token != NULL) {
        if (count == 0) {
            msg->temperature1 = atof(token);
        } else if (count == 1) {
            msg->temperature2 = atof(token);
        }
        token = strtok(NULL, " ");
        count++;
    }
}

int main(int argc, char* argv[]) {
    {
	zcm_t *zcm = zcm_create("udpm://234.255.76.67:7667?ttl=1");
	int fd, dl;
	int stop = 0;
	// system( "MODE /dev/ttyACM0: BAUD=9600 PARITY=n DATA=8 STOP=1" );
	fd = open("/dev/ttyACM0", O_RDWR | O_NOCTTY);
	dl = open("/dev/ttyACM1", O_RDWR | O_NOCTTY);
	char buf[256];
	char buf2[256];
	// char accx[256];
	// char accy[256];
	// char accz[256];
	char accel[256];
	char gyro[256];
	char mag[256];
	char press[256];
	char prox[256];
	// char dist[256];
	char s_dist[256];
	char l_dist[256];

	// int n = read(serialPort, &buf, 128);
	sensor_info_t msg;
	// printf("%s\n",buf);
	struct termios toptions;

	/* Get currently set options for the tty */
	tcgetattr(fd, &toptions);

	/* Set custom options */

	/* 9600 baud */
	cfsetispeed(&toptions, B9600);
	cfsetospeed(&toptions, B9600);
	/* 8 bits, no parity, no stop bits */
	toptions.c_cflag &= ~PARENB;
	toptions.c_cflag &= ~CSTOPB;
	toptions.c_cflag &= ~CSIZE;
	toptions.c_cflag |= CS8;
	/* no hardware flow control */
	toptions.c_cflag &= ~CRTSCTS;
	/* enable receiver, ignore status lines */
	toptions.c_cflag |= CREAD | CLOCAL;
	/* disable input/output flow control, disable restart chars */
	toptions.c_iflag &= ~(IXON | IXOFF | IXANY);
	/* disable canonical input, disable echo,
	disable visually erase chars,
	disable terminal-generated signals */
	toptions.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);
	/* disable output processing */
	toptions.c_oflag &= ~OPOST;

	/* wait for 1 character to come in before read returns */
	/* WARNING! THIS CAUSES THE read() TO BLOCK UNTIL ALL */
	/* CHARACTERS HAVE COME IN! */
	toptions.c_cc[VMIN] = 1;
	/* no minimum time to wait before read returns */
	toptions.c_cc[VTIME] = 0;

	/* commit the options */
	tcsetattr(fd, TCSANOW, &toptions);

	/* Wait for the Arduino to reset */
	usleep(1000 * 1000);
	/* Flush anything already in the serial buffer */
	tcflush(fd, TCIFLUSH);

	msg.accelerometer_x = 11.3;
	msg.accelerometer_y = 11.3;
	msg.accelerometer_z = 11.3;
	msg.gyroscope_x = 4.5;
	msg.gyroscope_y = 5.6;
	msg.gyroscope_z = 7.1;
	// msg.imu_gyroscope= atof(gyro);
	// msg.pressure = 180;
	// msg.pressure = atof(press);
	// msg.temperature1 = 56;
	// msg.temperature2 = 56;
	// msg.temperature1 = atof(buf); // TODO: Get value from arduino
	// msg.distance = 9.0;
	// msg.distance = atof(dist);
	msg.short_dist = 12;
	// msg.long_dist = 150;

	while (stop == 0)
	{
		/* read up to 128 bytes from the fd */
		int n = read(fd, &buf, 128);
		int k = read(dl, &buf2, 128);
		usleep(500 * 1000);
		/* print how many bytes read */
		printf("%i bytes got read...\n", n);
		// printf("%i bytes got read...\n", k);
		/* print what's in the buffer */
		printf("Buffer 1 contains...\n%s\n", buf);
		printf("Buffer 2 contains...\n%s\n", buf2);
		char *token = strtok(buf, " ");
		int count = 0;
		while (token != NULL)
		{
			if (count == 0)
			{
				msg.temperature1 = atof(token);
			}
			else if (count == 1)
			{
				msg.temperature2 = atof(token);
			}
			// else if (count == 2)
			// {
			// 	// msg.accelerometer_x = atof(token);
			// }
			// else if (count == 3)
			// {
			// 	// msg.accelerometer_y = atof(token);
			// }
			// else if (count == 4)
			// {
			// 	msg.accelerometer_z = atof(token);
			// }
			// else if (count == 5)
			// {
			// 	msg.gyroscope_x = atof(token);
			// }
			// if (count == 6)
			// {
			// 	msg.gyroscope_y = atof(token);
			// }
			// if (count == 7)
			// {
			// 	msg.gyroscope_z = atof(token);
			// }
			// if (count == 8)
			// {
			// 	msg.short_dist = atof(token);
			// }
			// if (count == 9)
			// {
			// 	msg.long_dist = atof(token);
			// }
			token = strtok(NULL, " ");
			count = count + 1;
		}
		char *token2 = strtok(buf2, " ");
		int count2 = 0;
		while (token2 != NULL)
		{
			if (count2 == 0)
			{
				msg.long_dist = atof(token2);
			}
			else if (count2 == 1)
			{
				msg.pressure = atof(token2);
			}
			token2 = strtok(NULL, " ");
			count2 = count2 + 1;
		}
		// msg.temperature1 = atof(buf); // TODO: Get value from arduino
		sensor_info_t_publish(zcm, "SENSOR_INFO", &msg);
		usleep(1000000);
	}

	while (1)
	{
		sensor_info_t_publish(zcm, "SENSOR_INFO", &msg);
		usleep(1000000); /* sleep for a second */
	}

	zcm_destroy(zcm);
	return 0;
}
}


#include "gtest/gtest.h"
#include <stdio.h>
#include "testing.cpp"




// Mock functions for testing
int mock_readData(int fd, char* buf, int bufSize) {
    strcpy(buf, "25.5 26.5"); // Mock data
    return 10;
}

// Unit tests
TEST(ReadDataTest, PositiveTest) {
    char buf[256];
    int result = readData(1, buf, 256);
    ASSERT_EQ(result, 10);
    ASSERT_STREQ(buf, "25.5 26.5");
}

TEST(ParseBufferTest, PositiveTest) {
    sensor_info_t msg;
    char buf[256];
    strcpy(buf, "25.5 26.5");
    parseBuffer(&msg, buf);
    ASSERT_FLOAT_EQ(msg.temperature1, 25.5);
    ASSERT_FLOAT_EQ(msg.temperature2, 26.5);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}






// subscribe.c tests

#include <gtest/gtest.h>
#include <cstdio>
#include <cstring>

extern "C" {
#include "subscribe.h"
}


// Test case for writeJson function
TEST_F(WriteJsonTest, TestWriteJson) {
    const char* testFileName = "test.json";

    // Create dummy sensor_info_t data for testing
    sensor_info_t dummyData[] = {
        {1, "Sensor1", 25.5, 70.0},
        {2, "Sensor2", 30.0, 65.5},
        // Add more test data as needed
    };

    size_t dataSize = sizeof(dummyData) / sizeof(dummyData[0]);

    // Call the function
    writeJson(testFileName, dummyData, dataSize);

    // Validate that the file is created
    FILE* fp = fopen(testFileName, "r");
    ASSERT_NE(fp, nullptr);


    sensor_info_t readData[dataSize];
    for (size_t i = 0; i < dataSize; ++i) {
        fscanf(fp, "%d %s %lf %lf", &readData[i].id, readData[i].name, &readData[i].temperature, &readData[i].humidity);
    }

    for (size_t i = 0; i < dataSize; ++i) {
        EXPECT_EQ(readData[i].id, dummyData[i].id);
        EXPECT_STREQ(readData[i].name, dummyData[i].name);
        EXPECT_DOUBLE_EQ(readData[i].temperature, dummyData[i].temperature);
        EXPECT_DOUBLE_EQ(readData[i].humidity, dummyData[i].humidity);
    }
TEST_F(WriteJsonTest, TestWriteJson) {
    const char* testFileName = "test.json";

    // Create dummy sensor_info_t data for testing
    sensor_info_t dummyData = {
        /* Initialize your test data based on the new structure */
        25.5,  // temperature1
        30.0,  // temperature2
        11.5,  // accelerometer_x
        9.6,   // accelerometer_y
        7.7,   // accelerometer_z
        4.5,   // gyroscope_x
        5.7,   // gyroscope_y
        2.3,   // gyroscope_z
        180.0, // pressure
        150.0, // long_dist
        12.0   // short_dist
    };

    //Call the function
    writeJson(testFileName, &dummyData, 1);

    // Validate that the file is created
    FILE* fp = fopen(testFileName, "r");
    ASSERT_NE(fp, nullptr);

    // Read contents of the file and validate the values
    sensor_info_t readData;
    fscanf(fp,
           "{\n"
           "  \"Temperature\": {\n"
           "    \"temperature1\": %f,\n"
           "    \"temperature2\": %f\n"
           "  },\n"
           "  \"accelerometer\": [%f, %f, %f],\n"
           "  \"gyroscope\": [%f, %f, %f],\n"
           "  \"Pressure\": %f,\n"
           "  \"Long-range sensor\": %f,\n"
           "  \"Short-range sensor\": %f\n"
           "}\n",
           &readData.temperature1, &readData.temperature2, &readData.accelerometer_x, &readData.accelerometer_y, &readData.accelerometer_z,
           &readData.gyroscope_x, &readData.gyroscope_y, &readData.gyroscope_z, &readData.pressure, &readData.long_dist, &readData.short_dist);

    // Compare read values with expected values
    EXPECT_DOUBLE_EQ(readData.temperature1, dummyData.temperature1);
    EXPECT_DOUBLE_EQ(readData.temperature2, dummyData.temperature2);
    EXPECT_DOUBLE_EQ(readData.accelerometer_x, dummyData.accelerometer_x);
    EXPECT_DOUBLE_EQ(readData.accelerometer_y, dummyData.accelerometer_y);
    EXPECT_DOUBLE_EQ(readData.accelerometer_z, dummyData.accelerometer_z);
    EXPECT_DOUBLE_EQ(readData.gyroscope_x, dummyData.gyroscope_x);
    EXPECT_DOUBLE_EQ(readData.gyroscope_y, dummyData.gyroscope_y);
    EXPECT_DOUBLE_EQ(readData.gyroscope_z, dummyData.gyroscope_z);
    EXPECT_DOUBLE_EQ(readData.pressure, dummyData.pressure);
    EXPECT_DOUBLE_EQ(readData.long_dist, dummyData.long_dist);
    EXPECT_DOUBLE_EQ(readData.short_dist, dummyData.short_dist);

    // Cleanup
    fclose(fp);
    remove(testFileName);
}

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
    // Cleanup required for Google Tests because I ran into issues without this
    fclose(fp);
    remove(testFileName);
}


// testing the printing of the writeJson function

TEST_F(WriteJsonTest, TestWriteJson) {
    const char* testFileName = "test.json";

    // Create dummy sensor_info_t data for testing
    sensor_info_t dummyData = {
        /* Initialize your test data based on the new structure */
        25.5,  // temperature1
        30.0,  // temperature2
        11.5,  // accelerometer_x
        9.6,   // accelerometer_y
        7.7,   // accelerometer_z
        4.5,   // gyroscope_x
        5.7,   // gyroscope_y
        2.3,   // gyroscope_z
        180.0, // pressure
        150.0, // long_dist
        12.0   // short_dist
    };

    // Call the function
    writeJson(testFileName, &dummyData, 1);

    // Validate that the file is created
    FILE* fp = fopen(testFileName, "r");
    ASSERT_NE(fp, nullptr);

    // Read contents of the file and validate the values
    sensor_info_t readData;
    fscanf(fp,
           "{\n"
           "  \"Temperature\": {\n"
           "    \"temperature1\": %f,\n"
           "    \"temperature2\": %f\n"
           "  },\n"
           "  \"accelerometer\": [%f, %f, %f],\n"
           "  \"gyroscope\": [%f, %f, %f],\n"
           "  \"Pressure\": %f,\n"
           "  \"Long-range sensor\": %f,\n"
           "  \"Short-range sensor\": %f\n"
           "}\n",
           &readData.temperature1, &readData.temperature2, &readData.accelerometer_x, &readData.accelerometer_y, &readData.accelerometer_z,
           &readData.gyroscope_x, &readData.gyroscope_y, &readData.gyroscope_z, &readData.pressure, &readData.long_dist, &readData.short_dist);

    // Compare read values with expected values
    EXPECT_DOUBLE_EQ(readData.temperature1, dummyData.temperature1);
    EXPECT_DOUBLE_EQ(readData.temperature2, dummyData.temperature2);
    EXPECT_DOUBLE_EQ(readData.accelerometer_x, dummyData.accelerometer_x);
    EXPECT_DOUBLE_EQ(readData.accelerometer_y, dummyData.accelerometer_y);
    EXPECT_DOUBLE_EQ(readData.accelerometer_z, dummyData.accelerometer_z);
    EXPECT_DOUBLE_EQ(readData.gyroscope_x, dummyData.gyroscope_x);
    EXPECT_DOUBLE_EQ(readData.gyroscope_y, dummyData.gyroscope_y);
    EXPECT_DOUBLE_EQ(readData.gyroscope_z, dummyData.gyroscope_z);
    EXPECT_DOUBLE_EQ(readData.pressure, dummyData.pressure);
    EXPECT_DOUBLE_EQ(readData.long_dist, dummyData.long_dist);
    EXPECT_DOUBLE_EQ(readData.short_dist, dummyData.short_dist);

    // Cleanup
    fclose(fp);
    remove(testFileName);
}

// Runs tests for all parts of the function

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}


// subscribe.c code for callback handler without any specifics, may need to ask more specifics
// Google Test for callback_handler
TEST(CallbackHandlerTest, PrintsMessageAndCallsWriteJson) {
    // Arrange
    MockZcmRecvBuf mockRbuf;
    const char* channel = "test_channel";
    MockSensorInfo mockMsg;
    MockVoid mockVoid;
    MockWriteJson mockWriteJson;

    callback_handler(&mockRbuf, channel, &mockMsg, &mockVoid);


}

int main(int argc, char** argv) {
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
